#!/bin/bash
#
# Copyright (c) 2014-2015 Simon Arjuna Erat (sea)  <erat.simon@gmail.com>
# All rights reserved.
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/gpl.txt>
#
# ------------------------------------------------------------------------
#
#	Author: 	Simon Arjuna Erat (sea)
#	Contact:	erat.simon@gmail.com
#	License:	GNU General Public License (GPL)
#	Created:	2014.04.26
#	Changed:	2015.01.13
#	Description:	A script to browse a folder recursivly,
#			using its start dir as 'BASE' which it wont leave ".."
#			Highly customable.
	. tui
	script_version=0.7.1
	[[ 0 -eq $UID ]] && \
		source /usr/share/tui/themes/$TUI_THEME_ROOT || \
		source /usr/share/tui/themes/$TUI_THEME

#
#	Variables
#
	TITLE="Project Browser"
	ME="${0##*/}"
	ME_DIR="${0/${0##/*/}}"
	help_text="
$ME ($script_version)
$TITLE
Usage: 	$ME [options] [arguments]
Where options are:
	-h(elp)		This screen

	-T(itle)	STR	Title-label (upper-left) will be labled as STR
	-U(ser) 	STR	User-label (upper-right) will be labled as STR
	-L(ocation)  	STR	Location will be labled as STR
	-P(osition)	STR	Position (/ some / dir) will be overwritten by STR
	
	-p(ath)		PATH	Will use ARG as basedir
	-n(oclear)		Dont clear screen after menu actions
	-s(ource)	PATH	Sources the file or all files, if its a path, exports its values and prints a dot
	-m(ode) 		Enables 'text' mode (nice looking)
				instead of 'numeric' (easy handling, default)
	
	-- Text Mode --
	-D(ir)  	STR	Folders will be labled as ARG
	-F(ile) 	STR	Files will be labled as ARG
	
	-- Advanced --
	-b(lacklist)	WORD	TODO: Add a WORD to the BLACKLIST of (linux-)commands not to be executed (Textmode only)
	-c(onfig)	FILE	Full path to configfile of the project
	-d(efault)	STR	Changes the filename startings from 'default' to 'NAME'
				These files will be hidden from the menu, and according to their
				extension be called on diffrent purposes...
				default.info	- Will be shown upon folder entry
				default.cmd	- Will be executed upon folder entry
	-S(show pos-line)	Forces the 'Location/Position' line to be shown when calling scripts
	-X(eXecute)	SHELL	Which shell to use to execute scripts, default bash
"
#
# 	Default Interface:
#
	# All
	lbl_title="$ME ($script_version) - $TITLE"	# 0 TOP RIGHT
	lbl_user="$USER_NAME @ $(date +'%F %T')"	# 0 TOP LEFT
	lbl_location="Location:"			# 1 TOP RIGHT
	lbl_position=""					# 1 TOP LEFT	-- unused yet
	# Textmode only
	lbl_dir="Section:"
	lbl_file="Task:"
#
#	Default Bool's
#
	doClear=true		# Wether to clear screen or not
	doTextmode=false	# false will show the numeric mode
	doBlacklist=false	# Will be enabled as soon "-b WORD" is passed
	doCustomPosition=false	# Will be enabled as soon "-P WORD" is passed
	showLocationPos_Anyway=false	# While false, this hides the 'Location' title line when calling a script directly
#
#	Default Strings
#
	menu=show
	PWD_OLD="$(pwd)"	# This is where the user actualy entered the command
	
	# Textmode only
	default_actions="delete edit execute help info new rename quit"
	
	# Advanced
	BLACKLIST=""		# Default entries to ignore when entered in Textmode
	declare -a CONFIG SOURCE # Configuration files to load (source & export)
	SPECIAL_NAME="default"	# Default name of the files parsed before displaying any content
	browser_shell="bash"	# This shell will be used to execute scripts, default bash
#
#	Internal defaults
#
	SPECIAL_EXT="info help cmd"	# For these 3 words there will be a handling. 'help' is only textmode!
	BASE=""				# What is the BASE for the LOCATION_DISPLAY
	## -- Multi menu
	#ARGS=""				# These are the arguments to the files and directories passed
	#OPTS=""				# These are the options to the files passed
# TODO	
	BROWSER_LIST_LOADED_VARIABLES=""	# This will contain all the variables that had been exported, to onload them when exiting without ^C.
#
#	Pre-functions
#
	MakeCurStr() { # PATH
	# Parses PATH and 'make it look nice'
	# Returns the 'nice looking string'
		[ -z "$1" ] && printf "Missing argument" && return 1
		str="$1"
		out=""
		# If PATH is just $BASE it shows a simple /, otherwise removing leading .
		echo "${str:0:1}" | $GREP -q '\.' && \
			out="${str:1}" || \
			out="$str"
		# Replace the slashes with something else  (space-slash-space)
		printf " $out"|$SED s\\"/"\\" / "\\g
	}
	GetStringDirs() { # ARGS[@]
	# Parses ARGS[@] and prints a 'path-string'
	#
		[[ -z "$BASE" ]] && return 1
		[[ -z "$1" ]] && return 1
		out="$BASE/"
		for a in "${@}";do
			[[ -d "$out/$a" ]] && out+="$a/"
		done
		echo "$out"
	}
	GetStringFile() { # ARGS[@]
	# Parses ARGS[@] and prints a 'path-string'
	#
		[[ -z "$BASE" ]] && return 1
		[[ -z "$1" ]] && return 1
		dir="$BASE/"
		for a in "${@}";do
			if [[ -d "$dir/$a" ]]
			then	dir+="$a/"
			elif [[ -f "$dir/$a" ]]
			then	file="$a"
			fi
		done
		echo "$file"
	}
	GetStringArgs() { # ARGS[@]
	# Parses ARGS[@] and prints a 'path-string'
	#
		[[ -z "$BASE" ]] && return 1
		[[ -z "$1" ]] && return 1
		dir="$BASE/"
		for a in "${@}";do
			if [[ -d "$dir/$a" ]]
			then	dir+="$a/"
				shift
			elif [[ -f "$dir/$a" ]]
			then	file="$a"
				shift
			else	echo "$@"
			fi
		done
	}
#
#	Catching Arguments
#
	#[[ -z $1 ]] && printf "$help_text" && exit $RET_HELP
	while getopts "hL:T:U:P:D:F:p:ns:mb:c:d:X:S" name
	do 	#echo "$name -- $OPTARG -- $OPTIND"	# DEBUG help	TODO rm when working
		case $name in
		h|help)		printf "$help_text"
				exit $RET_HELP		;;
		
		L|location)	lbl_location="$OPTARG"	;;
		T|title)	lbl_title="$OPTARG"	;;
		U|user) 	lbl_user="$OPTARG"	;;
		P|position)	lbl_position="$OPTARG"
				doCustomPosition=true	;;
		
		p|path) 	BASE="$OPTARG"		;;
		n|noclear)	doClear=false		;;
		s|source) 	SOURCE[${#SOURCE[@]}]="$OPTARG"	;;
		m|mode)		doTextmode=true 	;;
		
		# text mode
		D|dir) 		lbl_dir="$OPTARG"	;;
		F|file) 	lbl_file="$OPTARG"	;;
		
		# Advanced
		b|blacklist) 	BLACKLIST+=" $OPTARG"	;;
		c|config)	CONFIG[${#CONFIG[@]}]="$OPTARG"	;;
		d|default)	SPECIAL_NAME="$OPTARG"	;;
		X|execute)	browser_shell="$OPTARG"	;;
		S)		showLocationPos_Anyway=true	;;
		esac
	done
	shift $(($OPTIND - 1))
	[[ -z "$BLACKLIST" ]] && \
		doBlacklist=false || \
		doBlacklist=true
	if ! which $browser_shell 1>/dev/zero 2>/dev/zero
	then	tui-status 1 "Invalid shell supplied or not installed: \"$browser_shell\""
		exit $?
	fi
	# This is recquired to hide these files in the both the numeric and text mode menu
	HIDE_THIS="$SPECIAL_NAME.{$(for S in ${SPECIAL_EXT[@]};do printf '$S,';done)}"
	# Go to the Base, or stay where you are when no "-p PATH" was supplied
	[[ -z "$BASE" ]] && BASE="$PWD_OLD" || cd "$BASE"
#
#	Functions
#
	ShowContent() { # ABSOLUTEPATH
	# Displays the content of a path
	# 
		[ -z "$1" ] && printf "Missing argument" && return 1
		if [ "" = "$(ls)" ]
		then 	tui-status 1 "Location is empty"
			tui-echo
		else	unset folders[@] files[@] ARRAY[@]
			L=M=R=""
			CD=0 ; CF=0	# Counters : dir + files
			# Fill specific arrays
			ARRAY=( * )
			for e in "${ARRAY[@]}";do
				# verify its not a 'default' file
				num=
				if  [[ ! "${e:0:${#SPECIAL_NAME}}." = "${SPECIAL_NAME}." ]] # || [[ ! ${e:0:-${#SPECIAL_EXT}+1} = ".$SPECIAL_EXT" ]]
				then	# Its not, so split entries to files & folders
					if [ -d "$e" ]
					then	folders[$CD]="$e"
						((CD++))
					else	files[$CF]="$e"
						((CF++))
					fi
				else	# Its a $SPECIAL_NAME (default file)
					case "${e:${#SPECIAL_NAME}+1}" in
					".cmd")		. "$e"
							;;
					info)		#echo "Show the INFO!"
							while read line;do
								tui-echo "$line"
							done < "$e"
							tui-echo
							;;
					# "help")		tui-status 111 "TODO $e - handling"
					#		;;
					esac
				fi
			done
			for task in folder files;do
				unset array
				# Counters C D E
				C=0 ; D=1 ; E=2
				# Show task and create specific array
				case $task in
				folder)	content_title="$lbl_dir"
					array=( "${folders[@]}" )
					;;
				files)	content_title="$lbl_file"
					array=( "${files[@]}" )
					;;
				esac
				# Dont show title if no entries available
				if [ ! 0 = "${#array[@]}" ]
				then 	tui-title "${content_title}:"
					tui-list -n "${array[@]}"
					# Display array
				#	while [ $E -le $[ ${#array[@]} + 2 ] ] ; do
				#		L="${array[$C]}"
				#		M="${array[$D]}"
				#		R="${array[$E]}"
				#		C=$[ $C + 3 ]
				#		D=$[ $D + 3 ]
				#		E=$[ $E + 3 ]
						# Only show lines with content
				#		[ -z $L ] || tui-echo "$L" "$M" "$R"
				#	done
				fi
			done
		fi
	}
#
#	Load Main configuration and SOURCEs
#
	THE_MEGA_CONFIG="$TUI_TEMP_DIR/$ME_CONFIGS.cfg.tmp"
	[[ -f "$THE_MEGA_CONFIG" ]] && rm -f "$THE_MEGA_CONFIG"
	touch "$THE_MEGA_CONFIG"
	
	LoadFile() { # LIST OF FILES OR FOLDERS TO EXPORT
	# This uses the variable THE_MEGA_CONFIG as a target file to store all configuration in
	# So outside the function, it is a single source command to get all the values
		ARRAY="${@}"
		if [[ ! "" = "$(echo ${ARRAY[@]})" ]]
		then	# There are config files
			for conf in "${ARRAY[@]}"
			do	# Warn the user that no configuration file was found
				conf="$(echo $conf)"
				if [[ -d "$conf" ]]
				then	# its a dir, source and export each of the files there
					# Supposibly the 'sources'
					cd "$conf"
					for f in *
					do	CONF_LIST=""
						# Load the values
						if [[ -f "$f" ]]
						then	printf "."
							#f="$(echo $f)"
							var=$(tui-conf-get -l "$f")
							cat "$f" >> "$THE_MEGA_CONFIG"
						fi
					done
					cd "$PWD_OLD"
				elif [[ -f "$conf" ]] 
				then	# Supposibly the configs
					printf "."
					conf="$(echo $conf)"
					var=$(tui-conf-get -l "$conf")
					cat "$conf" >> "$THE_MEGA_CONFIG"
				else	tui-printf -S 111 "Warning! No file to source found (in): $conf"
					tui-wait 3s "Continue in:"
				fi
			done
		fi
	}
	# Prepare the configurations
	[[ ! "" = "$(echo ${CONFIG[@]})" ]] && LoadFile "${CONFIG[@]}"
	[[ ! "" = "$(echo ${SOURCE[@]})" ]] && LoadFile "${SOURCE[@]}"
	
	# Now load and export all the values:
	source "$THE_MEGA_CONFIG"
	BROWSER_LIST_LOADED_VARIABLES=$(tui-conf-get -l "$THE_MEGA_CONFIG")
	for entry in $BROWSER_LIST_LOADED_VARIABLES
	do	export $entry
	done
#
#	Display & Action
#
	sleep 0.03	# This is required for arrangement (in WM cases)
	len="${#BASE}"
	cd "$BASE"	# Change to BASE before displaying anything
	
	# Arguments been passed
	if [[ ! -z "$1" ]]
	then	# Change to directory
		#set -x
		for d in "${@}";do
			[[ -d "$d" ]] && cd "$d" && shift
		done
		CURRENT="$PWD"
		
		
		# Prepare heading string
		if $doCustomPosition
		then	POSITION="$lbl_position"
		else	# Orginal
		#	if [[ "${BASE:0:(-1)}" = "$CURRENT" ]]
		#	then	CUR_STR=""
		#	else	CURRENT=${CURRENT} #:${#BASE}}
		#		CUR_STR=$(MakeCurStr "${CURRENT:$len}") || exit 1
				#CUR_STR=$(MakeCurStr "${CURRENT}") #|| exit 1
		#	fi
			
			#set +x
			
			# Neu
			if [[ 0 -ne $# ]]
			then	#CURRENT="$(GetStringDirs "${@}" )"
				[ "$BASE" = "$CURRENT" ] && \
					CUR_STR="" || \
					CUR_STR=$(MakeCurStr "${CURRENT:$len}")
			else	CUR_STR=""
			fi
			
			# Beides
			POSITION="/$CUR_STR"
		fi
		
		# Parse arguments, execute the file or enter the folder
		file=$(GetStringFile "${@}")
		args=$(GetStringArgs "${@}")
		#set -x
		if [[ ! -z "$file" ]] && [[ -f "$CURRENT/$file" ]]  #&& [[ ! "$CURRENT/" = "$CURRENT/$file" ]]
		then	# Print top header
			tui-header "$lbl_title" "$lbl_user"
			# The title is not required, since a script is executed
			$showLocationPos_Anyway && tui-title "$lbl_location"  "$POSITION"
			# Execute it
			
			out=""
			for a in "${@:1}";do out+=" $a";done
			#set -x
			$browser_shell "$CURRENT/$file" $args
			tui-status $? "${lbl_title}${out}"
			exit $?
		else	# There is nothing to execute
			# Simply change dir and let the menu loop display the heading
			cd "$CURRENT"
		fi
	fi

#
##
###
####
###
##
#
	while [ ! $menu = "quit-browser" ];do
	#
	#	Set vars that must be re-read/set upon reload of current dir
	#
		#CURRENT="$(GetStringDirs "$PWD" )"
		CURRENT="$PWD"
		#echo $CURRENT/$mode
		#set -x
		# Prepare heading string
		if $doCustomPosition
		then	POSITION="$lbl_position"
		else	# Orginal
			#set -x
			CURRENT="$PWD"
			if [[ "${BASE:0:(-1)}" = "$CURRENT" ]]
			then	CUR_STR=""
			else	#CURRENT=${CURRENT:${#BASE}}
				CUR_STR=$(MakeCurStr "${CURRENT:$len}") || exit 1
			fi
			#set +x
			# Neu
		#	if [[ 0 -ne $# ]]
		#	then	CURRENT="$(GetStringDirs "${@}" )"
		#		[ "$BASE" = "$CURRENT" ] && \
		#			CUR_STR="" || \
		#			CUR_STR=$(MakeCurStr "${CURRENT:$len}")
		#	else	CUR_STR=""
		#	fi
			
			# Beides
			POSITION="$CUR_STR"
		fi
		#set +x
		#tui-press
	#
	#	Display	- TOP MENU
	#
		$doClear && clear
		tui-header "$lbl_title" "$lbl_user"
		tui-title "$lbl_location"  "$POSITION"
		
		# This must be double, since its outside the loop
		if ! $doTextmode
		then	for T in info help;do
				case $T in
				"$SPECIAL_NAME.cmd")
					. "$SPECIAL_NAME.cmd"
					;;
				help)	[[ -f $SPECIAL_NAME.help ]] && tui-echo "TODO: $(pwd) help" ;;
				*)	[[ -f $SPECIAL_NAME.$T ]] && \
						while read line;do tui-echo "$line";done<$SPECIAL_NAME.$T
					;;
				esac
			done
		fi			
	#
	#	MENU :: TEXT
	#
		if $doTextmode ; then
		#
		#	DISPLAY - Show content
		#
			ShowContent "$CURRENT"
		#
		#	Fetch input
		#
			tui-echo
			read -p "$BORDER_LEFT What is your choice: " mode item newval spare
		#
		#	Deside action
		#	
			if [ ! -z "$mode" ]; then
			# Expect $mode to be either an item of $default_actions
			# or a file / folder
				case $mode in
				n|new)  	menu=new
						[ -z "$item" ] && \
							item=(tui-read "What is the name:")
						tui-yesno "Will $item be a folder?" && \
							mnu_Folder c "$item" || \
							mnu_File c "$item"
						;;
				[bB]|[bB]ack)	# Exit if 'leaving' base directory
						[ "$CURRENT" = "$BASE" ] && \
							menu="quit-browser" || \
							menu="back"
						;;
				d|delete)	menu=del
						[ -z "$item" ] && \
							tui-echo "Please select what you want to delete:" && \
							select item in "${ARRAY[@]}";do break;done
						[ -d "$item" ] && \
							mnu_Folder d "$item" || \
							mnu_File d "$item"
						;;
				e|edit) 	menu=edit
						skip=true
						[ -z "$item" ] && \
							tui-echo "Please select a file to edit:" && \
							select item in "${files[@]}";do break;done
						[ -d "$item" ] && \
								ERROR_MSG="Cant edit a folder!" && \
								skip=true || \
								( [ -f "$item" ] && skip=false )
						[ $skip = false ] && \
							mnu_File  edit "$item"	
						;;
				x|execute)	menu=exe
						if [ -z "$item" ]
						then	ERROR_MSG="Nothing provided to execute!"
						else	[ -d "$item" ] && \
								mnu_Folder x "$item" || \
								( mnu_File x "$item" ; tui-press)
						fi					;;
				i|info) 	menu=info
						if [ -z "$item" ]
						then	ERROR_MSG="Nothing provided to execute!"
						else	stat "$item"
							tui-press
						fi					;;
				r|rename)	menu=rename
						if [ -z "$item" ]
						then	ERROR_MSG="Nothing provided to execute!"
						else	stat "$item"
							tui-press
						fi					;;
				[qQ]|[qQ]uit)	menu="quit-browser"			;;
				*)		# Its not a $default_action
						menu=diffrent
						if [ -z "$item" ]
						then	# No 2nd argument passed
							if [ -d "$mode" ]
							then	cd "$mode"
							elif [ -f "$mode" ]
							then	mnu_File "execute" "$mode"
								tui-press
							fi
						else	tui-echo "BETA shell execute?:" "'$mode $item'"
							$mode $item
							tui-press
						fi					;;
				esac
			fi
		elif ! $doTextmode ; then
		#
		# MENU :: NUM
		#
			select e in $(ls|$GREP -v $SPECIAL_NAME. ) Back Quit;do 
				case "$e" in
				Back)	menu="back"
					break	;;
				Quit)	menu="quit-browser"
					exit 0	;;
				*)	menu=up
					[ -f "$e" ] &&  ./"$e"
					[ -d "$e" ] && cd "$e"
					break
					;;
				esac
			done
		else	tui-status 1 "Error, MENU_MODE = $MENU_MODE"
		fi
	# Check for BACK
	# Exit if 'leaving' base directory
		if [ $menu = back ]
		then	[ "$CURRENT" = "$BASE" ] && \
				menu="quit-browser" || \
				cd ..
		fi
	done
	cd "$PWD_OLD"
#
#	Onload 'environment'
#
	for var in $BROWSER_LIST_LOADED_VARIABLES ; do
		cmd="$var=\"\" ; export $var"
		$cmd
	done
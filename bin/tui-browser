#!/bin/bash
#
#	Author: 	Simon Arjuna Erat (sea)
#	Contact:	erat.simon@gmail.com
#	License:	GNU Lesser General Public License (LGPL)
#	Created:	2014.04.26
#	Changed:	2014.04.26
	script_version=0.1
#	Description:	Descriptional text goes here
#
#	Variables
#
	source tui
	TITLE="Basic File Browser for the cli"
	ME="${0##*/}"
	ME_DIR="${0/${0##/*/}}"
	help_text="
$ME ($script_version)
$TITLE
Usage: 	$ME [options] [arguments]
Where options are:
	-h|--help		This screen
	-t|--title	ARG	Title-label (upper-left) is set to ARG
	-u|--user	ARG	User-label (upper-right) is set to ARG
	-d|--dir	ARG	Folders will be labled as ARG
	-f|--file	ARG	Files will be labled as ARG

"
	# Default Interface:
	lbl_title="$ME ($script_version) - $TITLE"
	lbl_user="$USER @ $(date +'%F %T')"
	lbl_time=""
	lbl_dir="Folders"
	lbl_file="Files"
	menu=show
	default_actions="create delete edit execute info help rename quit"
	PWD_OLD="$(pwd)"
#
#	Pre-funccction
#
	MakeCurStr() { # PATH
	# Parses PATH and 'make it look nice'
	# Returns the 'nice looking string'
		[ -z $1 ] && printf "Missing argument" %s && return 1
		str="$1"
		out=""
		# If PATH is just $BASE it shows a simple /, otherwise removing leading .
		[ "." = "$str" ] && \
			out="/" || \
			out="${str:1}"
		# Replace the slashes with something else
		printf " $out"|sed s\\"/"\\" / "\\g
	}
#
#	Catching Arguments
#
	#[[ -z $1 ]] && printf "$help_text" && exit $RET_HELP
	while getopts "m:d:f:t:u:h(help)": name
	do 	#echo "$name -- $OPTARG -- $OPTIND"	# DEBUG help	TODO rm when working
		case $name in
		t|title)	lbl_title="$OPTARG"	;;
		u|user) 	lbl_user="$OPTARG"	;;
		d|dir) 		lbl_dir="$OPTARG"	;;
		f|file) 	lbl_file="$OPTARG"	;;
		m|mode)		mode="$OPTARG"		;;
		h|help)		printf "$help_text"
				exit $RET_HELP		;;
		esac
	done
	shift $(($OPTIND - 1))
	
	# Remaining argument should be BASE
	ARGS=(${*})			# Remaining arguments
	ARGS_COUNT=${#ARGS[@]}		# Amount of remaining
	for a in "${ARGS[@]}";do BASE="$a";done
	
	# Verify required variables
	[ -z $BASE ] && BASE="$(pwd)"
	CURRENT="$BASE"	# Relative path after base
	CUR_STR=$(MakeCurStr "$CURRENT")
	[ -z $lbl_dir ] && tui-echo "Error retrieving 'Folders'-label..." "$FAIL" && exit 1
#
#	Functions
#
	mnu_Folder() { # ACTION NAME [NEWVAL]
	# Shows the menu for $default_actions
	# Folder-sepecific
		[ -z $2 ] && printf %s "Usage: mnu_Folder ACTION NAME" && exit 1
		action="$1" ; item="$2" ; newval="$3"
		case $action in
		c|create)	mkdir "$item" 		;;
		d|delete)	tui-yesno "Delete $item and all of its subfolders" && \
				rm -fr "$item"		;;
		m|rename)
				[ -z $newval ] && newval=$(tui-read "What is the new name: ")
				mv "$item" "$newval"	;;
		x|execute)	cd "$item"		;;
		esac
	}
	mnu_File() { # ACTION NAME [NEWVAL]
	# Shows the menu for $default_actions
	# Folder-sepecific
		[ -z $2 ] && printf %s "Usage: mnu_File ACTION NAME [NEW_VAL]" && exit 1
		action="$1" ; item="$2" ; newval="$3"
		case $action in
		c|create)	touch "$item"
				tui-edit "$item"	;;
		d|delete)	tui-yesno "Delete $item" && \
					rm -f "$item"	;;
		e|edit) 	tui-edit "$item"	;;
		i|info)		stat "$item"		;;
		m|rename)	[ -z $newval ] && \
					newval=$(tui-read "What is the new name: ")
				mv "$item" "$newval"	;;
		x|execute)	! ./"$item" && \
					tui-echo "Direct call failed..." "$FAIL" && \
					tui-echo "Attempt to call it as $USER_SHELL." && \
					$USER_SHELL "$item"	;;
		esac
	}
	ShowContent() { # ABSOLUTEPATH
	# Displays the content of a path
	# 
		[ -z $1 ] && printf %s "Missing argument" && return 1
		if [ "" = "$(ls)" ]
		then 	tui-status 1 "Location is empty"
			tui-echo
		else	unset folders[@] files[@] ARRAY[@]
			L=M=R=""
			CD=0 ; CF=0	# Counters : dir + files
			# Fill specific arrays
			ARRAY=( * )
			for e in "${ARRAY[@]}";do
				if [ -d "$e" ]
				then	folders[$CD]="$e"
					((CD++))
				else	files[$CF]="$e"
					((CF++))
				fi
			done
			for task in folder files;do
				unset array
				# Counters C D E
				C=0 ; D=1 ; E=2
				# Show task and create specific array
				case $task in
				folder)	[ -z $lbl_dir ] && \
						content_title="$lbl_dir_default" || \
						content_title="$lbl_dir"
					array=( "${folders[@]}" )
					;;
				files)	[ -z $lbl_file ] && \
						content_title="$lbl_file_default" || \
						content_title="$lbl_file"
					array=( "${files[@]}" )
					;;
				esac
				# Dont show title if no entries available
				[ ! "x" = "$(printf x${array[@]})" ] && \
					tui-title "${content_title}:"
				# Display array
				while [ $E -le $[ ${#array[@]} + 2 ] ] ; do
					L="${array[$C]}"
					M="${array[$D]}"
					R="${array[$E]}"
					C=$[ $C + 3 ]
					D=$[ $D + 3 ]
					E=$[ $E + 3 ]
					# Only show lines with content
					[ ! "" = "$(echo $L$M$R)" ] && \
						tui-echo "$L" "$M" "$R"
				done
			done
			
		fi
	}
	has_shebang() { # FILE
	# Returns successfully if file begins with '#/bin' or '#!/bin'
	# Fails otherwise
		head "$1" -n1 | grep ^"#[!]/bin" && \
			return 0 || return 1
	}
	is_less_kb() { # FILE NUM
	# Returns successfully if FILE-size is lower than NUM
	# Fails otherwise
		size=$(ls -l "$1" | awk '{print $5}')
		[ $size -lt $2 ] && \
			return 0 || return 1
	}
	func() { # Argument examples
	# Returns successfully if 
	# Text here
		echo $1
	}
#
#	Display & Action
#
	cd "$CURRENT"
	while [ ! $menu = "quit-browser" ]
	do	#
		#	Set vars that must be re-read/set upon reload of current dir
		#
		CURRENT="$(pwd)"
		len="${#BASE}"
		[ "$BASE" = "$CURRENT" ] && \
			CUR_STR="" || \
			CUR_STR=$(MakeCurStr "${CURRENT:$len}") || exit 1
		#
		#	Display	- TOP MENU
		#
		clear
		tui-header "$lbl_title" "$lbl_user"
		tui-title "Location:" "" "/$CUR_STR"
		#
		#	DISPLAY - Show content
		#
		ShowContent "$CURRENT"
		#
		#	Fetch input
		#
		tui-echo
		read -p "$BORDER_LEFT What is your choice: " mode item newval spare
		#
		#	Deside action
		#	
		if [ ! -z $mode ]; then
		# Expect $mode to be either an item of $default_actions
		# or a file / folder
			case $mode in
			c|create)	[ -z $item ] && \
						item=(tui-read "What is the name:")
					tui-yesno "Will $item be a folder?" && \
						mnu_Folder c "$item" || \
						mnu_File c "$item"
					;;
			[bB]|[bB]ack)	# Exit if 'leaving' base directory
					[ "$CURRENT" = "$BASE" ] && \
						menu="quit-browser" || \
						cd ..
					;;
			d|delete)	[ -z $item ] && \
						tui-echo "Please select what you want to delete:" && \
						select item in "${ARRAY[@]}";do break;done
					[ -d "$item" ] && \
						mnu_Folder d "$item" || \
						mnu_File d "$item"
					;;
			e|edit) 	skip=true
					[ -z $item ] && \
						tui-echo "Please select a file to edit:" && \
						select item in "${files[@]}";do break;done
					[ -d "$item" ] && \
							ERROR_MSG="Cant edit a folder!" && \
							skip=true || \
							( [ -f "$item" ] && skip=false )
					[ $skip = false ] && \
						mnu_File  edit "$item"	
					;;
			x|execute)	if [ -z $item ]
					then	ERROR_MSG="Nothing provided to execute!"
					else	[ -d "$item" ] && \
							mnu_Folder x "$item" || \
							( mnu_File   x "$item" ; tui-press)
					fi					;;
			i|info) 	if [ -z $item ]
					then	ERROR_MSG="Nothing provided to execute!"
					else	stat "$item"
						tui-press
					fi					;;
			r|rename)	if [ -z $item ]
					then	ERROR_MSG="Nothing provided to execute!"
					else	stat "$item"
						tui-press
					fi					;;
			[qQ]|[qQ]uit)	menu="quit-browser"			;;
			*)		# Its not a $default_action
					if [ -z $item ]
					then	# No 2nd argument passed
						if [ -d "$mode" ]
						then	cd "$mode"
						elif [ -f "$mode" ]
						then	mnu_File "execute" "$mode"
							tui-press
						fi
					else	tui-echo "BETA shell include?:"
						$mode $item
						tui-press
					fi					;;
			esac
		fi
	done
	cd "$PWD_OLD"

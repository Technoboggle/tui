#!/bin/bash
#
# Copyright (c) 2014 Simon Arjuna Erat (sea)  <erat.simon@gmail.com>
# All rights reserved.
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>
#
# ------------------------------------------------------------------------
#
#
#	Author: 	Simon Arjuna Erat (sea)
#	Contact:	erat.simon@gmail.com
#	License:	GNU General Public License (GPL)
#	Created:	2013.05.03
#	Changed:	2014.07.27
	script_version=0.9
#	Description:	Descriptional text goes here
#
#	Variables
#
	#source tui
	[ -z "$BORDER_LEFT$HEAD_BG" ] && source /etc/profile.d/tui.sh
	TITLE="tui-printf"
	ME="${0##*/}"
	ME_DIR="${0/${0##/*/}}"
	help_text="
$ME ($script_version)
$TITLE
Usage: 	$ME [options] [arguments]
	$ME		Prints up to 3 arguments. 
			1: Left
			2: Left, Right
			3: Left, Center, Right
Arguments will tell $ME if and where to colorize, or if to do a linebreak.
Options are:
	-h(elp) 	This screen
	-E(cho)		Simulates 'echo', prints up to 3 strings and a newline.
	-T(itle)	Prints 1st argument centred, if more - aligment like tui-echo
			The inner background is colored white with blue font by default
	-H(header)	Full line has a blue background and white font as default color
"
	FIRST=""
	SECOND=""
	THIRD=""
	#WIDTH=$( [ -z $COLUMNS ] && tput cols || printf $COLUMNS )	# Retrieve env or calc it new
	WIDTH=${COLUMNS:âˆ’$(tput cols)} 
	#WIDTH=$[ $WIDTH - ${#BORDER_LEFT} - ${#BORDER_RIGHT} - 2 ]	# Subtract default 'borders'
	((WIDTH -= (${#BORDER_LEFT} + ${#BORDER_RIGHT} + 2))) 
	WIDTH=$[ $WIDTH / 2 * 2 ]					# Make it even 
	EMPTY="$(printf '%*s' $WIDTH)"					# Get 'width' spaces
	doEcho=1
	doHeader=1
	doTitle=1
	optStyle=""
#
#	Catching Arguments
#
	while getopts "EHTh?" name
	do 	case $name in
		E|echo) 	doEcho=0
				optStyle="-E"	;;
		H|header)	doHeader=0
				optStyle="-H"	;;
		T|title)	doTitle=0
				optStyle="-T"	;;
		h|"?"|*)	printf "$help_text"
				exit $RET_HELP
				;;
		esac
	done
	shift $(($OPTIND - 1))
	ARGS_COUNT=0
	[ ! -z "$1" ] && FIRST="$1" && ((ARGS_COUNT++))
	[ ! -z "$2" ] && SECOND="$2" && ((ARGS_COUNT++))
	[ ! -z "$3" ] && THIRD="$3" && ((ARGS_COUNT++))
	[ ! -z "$4" ] && doMore=0 || doMore=1
#
#	Verify all fit on 1 line
#
	len=$[ ${#FIRST} + ${#SECOND} + ${#THIRD} ]
	if [[ $len -gt $WIDTH ]]
	then 	len2=$[ ${#FIRST} + ${#SECOND} ]
		#echo $len $len2 $WIDTH
		if [[ $len2 -le $WIDTH ]]
		then 	# first & second match on one line
			tui-printf -E "$FIRST" "$SECOND"
			tui-printf $optStyle "$THIRD"
		else	# it needs further spliting:
			if [[ ${#FIRST} -le $WIDTH ]]
			then 	tui-printf -E "$FIRST"
				tui-printf $optStyle "$SECOND" "$THIRD"
			else	half=$[ ${#FIRST} / 2 ]
				part1="${FIRST:0:$half}"
				part2="${FIRST:$half}"
				tui-printf -E "$part1"
				[[ -z $SECOND ]] && \
					tui-printf -E "$part2" || \
					tui-printf -E "$part2" "$SECOND"
				[[ -z $THIRD ]] || \
					tui-printf $optStyle "$THIRD"
			fi
		fi
		# Since this is special handling, 
		# calling itself with reduced string lengths
		# so we can exit after this is done
		exit
	# else # just continue with the script below
	fi
#
#	Prepare Colors & Strings
#
	if [ $doEcho ]
	then	COLOR_LINE_START="\r${TUI_RESET}"
		COLOR_LINE_IDENT=""
		COLOR_LINE_CLOSE=""
		COLOR_LINE_END="\n"
	elif [ $doHeader ]
	then	# Full line
		COLOR_LINE_START="\r${HEAD_BG}${HEAD_FG}"
		COLOR_LINE_IDENT=""
		COLOR_LINE_CLOSE=""
		COLOR_LINE_END="${TUI_RESET}\n"
	elif [ $doTitle ]
	then	# 'Inlay'
		COLOR_LINE_START="\r"
		COLOR_LINE_IDENT="${TITLE_FG}${TITLE_BG}"
		COLOR_LINE_CLOSE="${TUI_RESET}"
		COLOR_LINE_END="\n"
	else	# The default
		COLOR_LINE_START="\r${TUI_RESET}"
		COLOR_LINE_IDENT=""
		COLOR_LINE_CLOSE=""
		COLOR_LINE_END=""
	fi
	case $ARGS_COUNT in
	0)	FIRST="$EMPTY"
		;;
	1)	if [ $doTitle ]
		then 	SECOND="$FIRST"
			num=$(($#SECOND / 2 * 2))
			[ $num -ne "${#SECOND}" ] && adder=' ' || adder=''
			EMPTY="${EMPTY:${num}+2}"	# The +2 is a temp bugfix
			half=$[ ${#EMPTY} / 2  ]
			FIRST="${EMPTY:$half}"
			THIRD="$FIRST$adder"
		else	# Usual arangement
			SECOND=$"${EMPTY:${#FIRST}}"
		fi
		;;
	2)	# Make the last (2nd) passed argument aligned to right
		THIRD="$SECOND"
		SECOND="${EMPTY:${#FIRST}+${#SECOND}}"
		;;
	*)	# 3 (BETA - and more - handler)
		EMPTY="${EMPTY:${#FIRST}+${#SECOND}+${#THIRD}}"
		half=$[ ${#EMPTY} / 2 ]
		
		len_strings=$[ ${#FIRST} + ${#SECOND} + ${#THIRD} ]
		adder=$((len_strings % 2))
		
		SECOND="${EMPTY:$half}$SECOND${EMPTY:$half+$adder}"
		;;
	esac
#
#	Display & Action
#
	#printf "${COLOR_LINE_START}${BORDER_LEFT}${COLOR_LINE_IDENT} ${FIRST}${SECOND}${THIRD} ${COLOR_LINE_CLOSE}${BORDER_RIGHT}${COLOR_LINE_END}"
	printf "${COLOR_LINE_START}${BORDER_LEFT}${COLOR_LINE_IDENT} %s ${COLOR_LINE_CLOSE}${BORDER_RIGHT}${COLOR_LINE_END}" "${FIRST}${SECOND}${THIRD}"
#
#	BETA "if more"
#
	#unset ARGS[0] ARGS[1] ARGS[2]
	if [ $doMore ]
	then	# there are remains..
		C=0
		for A in "${ARGS[*]}";do 
			[ "$1" = "$A" ] && unset ARGS[$C] && echo $A
			[ "$2" = "$A" ] && unset ARGS[$C] && echo $A
			[ "$3" = "$A" ] && unset ARGS[$C] && echo $A
			((C++))
		done
		tui-title "DEBUG"
		tui-echo  "Too many arguments:" "$ARGS_COUNT($ARGS_COUNT_org)=${ARGS[*]}"
		# DEBUG
		echo $ME $optStyle "${ARGS[*]}"
		exit
	fi

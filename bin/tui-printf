#!/bin/bash
#
# Copyright (c) 2014 Simon Arjuna Erat (sea)  <erat.simon@gmail.com>
# All rights reserved.
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>
#
# ------------------------------------------------------------------------
#
#
#	Author: 	Simon Arjuna Erat (sea)
#	Contact:	erat.simon@gmail.com
#	License:	GNU General Public License (GPL)
#	Created:	2013.05.03
#	Changed:	2014.06.10
	script_version=0.9.1
#	Description:	Descriptional text goes here
#
#	Variables
#
	#source tui
	[ -z $HEAD_BG ] && source /etc/profile.d/tui.sh
	TITLE="tui-printf"
	ME="${0##*/}"
	ME_DIR="${0/${0##/*/}}"
	help_text="
$ME ($script_version)
$TITLE
Usage: 	$ME [options] [arguments]
	$ME		Prints up to 3 arguments. 
			1: Left
			2: Left, Right
			3: Left, Center, Right
Arguments will tell $ME if and where to colorize, or if to do a linebreak.
Options are:
	-h(elp) 	This screen
	-E(cho)		Simulates 'echo', prints up to 3 strings and a newline.
	-T(itle)	Prints 1st argument centred, if more - aligment like tui-echo
			The inner background is colored white with blue font by default
	-H(header)	Full line has a blue background and white font as default color
"
	FIRST=""
	SECOND=""
	THIRD=""
	WIDTH=$( [ -z $COLUMNS ] && tput cols || printf $COLUMNS )	# Retrieve env or calc it new
	#WIDTH=${COLUMNS:−$(tput cols)} 
	#WIDTH=$[ $WIDTH - ${#BORDER_LEFT} - ${#BORDER_RIGHT} - 2 ]	# Subtract default 'borders'
	((WIDTH -= (${#BORDER_LEFT} + ${#BORDER_RIGHT} + 2))) 
	WIDTH=$[ $WIDTH / 2 * 2 ]					# Make it even 
	EMPTY="$(printf '%*s' $WIDTH)"					# Get 'width' spaces
	doEcho=false
	doHeader=false
	doTitle=false
	optStyle=""
#
#	Catching Arguments
#
	#[[ -z $1 ]] && printf "$help_text" && exit $RET_HELP
	while getopts "EHTh?" name
	do 	case $name in
		E|echo) 	doEcho=true
				optStyle="-E"	;;
		H|header)	doHeader=true
				optStyle="-H"	;;
		T|title)	doTitle=true
				optStyle="-T"	;;
		h|"?"|*)	printf "$help_text"
				exit $RET_HELP
				;;
		esac
	done
	shift $(($OPTIND - 1))
	ARGS=("${*}")			# Remaining arguments	| These two fail on spaced-strings
	ARGS_COUNT_org=${#ARGS[@]}	# Amount of remaining
	#FIRST="${ARGS[0]}"
	#SECOND="${ARGS[1]}"
	#THIRD="${ARGS[2]}"
	ARGS_COUNT=0
	[ ! -z "$1" ] && FIRST="$1" && ((ARGS_COUNT++))
	[ ! -z "$2" ] && SECOND="$2" && ((ARGS_COUNT++))
	[ ! -z "$3" ] && THIRD="$3" && ((ARGS_COUNT++))
	[ ! -z "$4" ] && doMore=true || doMore=false
	[ -z $optStyle ] && optStyleTMP="-E" || optStyleTMP="$optStyle"
#
#	Verify all fit on 1 line
#
	len=$[ ${#FIRST} + ${#SECOND} + ${#THIRD} ]
	if [[ $len -gt $WIDTH ]]
	then 	# All vars are larger than the line supports
		# Splitting required
		case $ARGS_COUNT in
		1)	# Split up the only argument passed
			#if [[ $len2 -le $WIDTH ]]
			#then 	# FIRST & SECOND match on one line
			#	tui-printf $optStyleTMP "$FIRST" "$SECOND"
				# Now prints the third and let it handle itself
			#	tui-printf $optStyle "$THIRD"
			#else	# FIRST needs further spliting:
			#	if [[ ${#FIRST} -le $WIDTH ]]
			#	then 	tui-printf $optStyleTMP "$FIRST"
			#		tui-printf $optStyle "$SECOND" "$THIRD"
			#	else
					half=$[ ${#FIRST} / 2 ]
					part1="${FIRST:0:$half}"
					part2="${FIRST:$half}"
				# unten hängt es
					tui-printf $optStyleTMP "$part1"
					tui-printf $optStyle "$part2"
				# oben hängt es
					#exit
				#	[[ -z $SECOND ]] && \
				#		tui-printf $optStyle "$part2" || \
				#		tui-printf $optStyle "$part2" "$SECOND"
				#	[[ -z $THIRD ]] || \
				#		tui-printf $optStyle "$THIRD"
			#	fi
			#fi
			;;
		2)	# Print each of the 2 arguments on a single line...
			tui-printf $optStyleTMP "$FIRST"
			tui-printf $optStyle "$SECOND"
			;;
		3)	# Print only 2 on the first line
			tui-printf $optStyleTMP "$FIRST" "$SECOND"
			tui-printf $optStyle "$THIRD"
			;;
		esac
		#set +x
		# Since this is special handling, 
		# calling itself with reduced string lengths
		# so we can exit after this is done
		exit
	# else # just continue with the script below
	fi
#
#	Prepare Colors & Strings
#
	if [ $doEcho = true ]
	then	COLOR_LINE_START="\r${TUI_COLOR_RESET}"
		COLOR_LINE_IDENT=""
		COLOR_LINE_CLOSE=""
		COLOR_LINE_END="${TUI_COLOR_RESET}\n${TUI_COLOR_RESET}"
	elif [ $doHeader = true ]
	then	# Full line
		COLOR_LINE_START="\r${HEAD_BG}${HEAD_FG}"
		COLOR_LINE_IDENT=""
		COLOR_LINE_CLOSE=""
		COLOR_LINE_END="${TUI_COLOR_RESET}\n${TUI_COLOR_RESET}"
	elif [ $doTitle = true ]
	then	# 'Inlay'
		COLOR_LINE_START="\r${TUI_COLOR_RESET}"
		COLOR_LINE_IDENT="${TITLE_FG}${TITLE_BG}"
		COLOR_LINE_CLOSE="${TUI_COLOR_RESET}"
		COLOR_LINE_END="${TUI_COLOR_RESET}\n${TUI_COLOR_RESET}"
	else	# The default
		COLOR_LINE_START="\r${TUI_COLOR_RESET}"
		COLOR_LINE_IDENT=""
		COLOR_LINE_CLOSE=""
		COLOR_LINE_END="${TUI_COLOR_RESET}"
	fi
	case $ARGS_COUNT in
	0)	FIRST="$EMPTY"
		;;
	1)	if [ $doTitle = true ]
		then 	SECOND="$FIRST"
			num_o="${#SECOND}"
			num=$[ $num_o / 2 * 2  ]
			[ $num_o -gt $num ] && adder=" "||adder="  "
			EMPTY="${EMPTY:${num}+2}"	# The +2 is a temp bugfix
			half=$[ ${#EMPTY} / 2  ]
			FIRST="${EMPTY:$half}"
			THIRD="$FIRST$adder"
		else	# Usual arangement
			SECOND=$"${EMPTY:${#FIRST}}"
		fi
		;;
	2)	# Make the last (2nd) passed argument aligned to right
		THIRD="$SECOND"
		SECOND="${EMPTY:${#FIRST}+${#SECOND}}"
		;;
	*)	# 3 (BETA - and more - handler)
		EMPTY="${EMPTY:${#FIRST}+${#SECOND}+${#THIRD}}"
		half=$[ ${#EMPTY} / 2 ]
		
		len_strings=$[ ${#FIRST} + ${#SECOND} + ${#THIRD} ]
		#len_compare=$[ $len_strings / 2 * 2  ]
		#[ $len_compare -lt $len_strings ] && \
		#	adder=1 || \
		#	adder=0
		adder=$((len_strings % 2))
		
		SECOND="${EMPTY:$half}$SECOND${EMPTY:$half+$adder}"
		;;
	esac
#
#	Display & Action
#
	printf "${COLOR_LINE_START}${BORDER_LEFT}${COLOR_LINE_IDENT} ${FIRST}${SECOND}${THIRD} ${COLOR_LINE_CLOSE}${BORDER_RIGHT}${COLOR_LINE_END}"
#
#	BETA "if more"
#
	#unset ARGS[0] ARGS[1] ARGS[2]
#	if [ $doMore = true ]
#	then	# there are remains..
#		C=0
#		for A in "${ARGS[*]}";do 
#			[ "$1" = "$A" ] && unset ARGS[$C] && echo $A
#			[ "$2" = "$A" ] && unset ARGS[$C] && echo $A
#			[ "$3" = "$A" ] && unset ARGS[$C] && echo $A
#			((C++))
#		done
#		tui-title "DEBUG"
#		tui-echo  "Too many arguments:" "$ARGS_COUNT($ARGS_COUNT_org)=${ARGS[*]}"
		# DEBUG
#		echo $ME $optStyle "${ARGS[*]}"
#		exit
#	fi

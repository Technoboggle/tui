#!/bin/bash
#
#	Author: 	Simon Arjuna Erat (sea)
#	Contact:	erat.simon@gmail.com
#	License:	GNU Lesser General Public License (LGPL)
#	Created:	2013.05.03
#	Changed:	2014.06.10
	script_version=0.9
#	Description:	Descriptional text goes here
#
#	Variables
#
	#source tui
	[ -z "$BORDER_LEFT$HEAD_BG" ] && source /etc/profile.d/tui.sh
	TITLE="tui-printf"
	ME="${0##*/}"
	ME_DIR="${0/${0##/*/}}"
	help_text="
$ME ($script_version)
$TITLE
Usage: 	$ME [options] [arguments]
	$ME		Prints up to 3 arguments. 
			1: Left
			2: Left, Right
			3: Left, Center, Right
Arguments will tell $ME if and where to colorize, or if to do a linebreak.
Options are:
	-h(elp) 	This screen
	-E(cho)		Simulates 'echo', prints up to 3 strings and a newline.
	-T(itle)	Prints 1st argument centred, if more - aligment like tui-echo
			The inner background is colored white with blue font by default
	-H(header)	Full line has a blue background and white font as default color
"
	FIRST=""
	SECOND=""
	THIRD=""
	WIDTH=$( [ -z $COLUMNS ] && tput cols || printf $COLUMNS )	# Retrieve env or calc it new
	TOTAL="$WIDTH"
	WIDTH=$[ $WIDTH - ${#BORDER_LEFT} - ${#BORDER_RIGHT} - 2 ]	# Subtract default 'borders'
	WIDTH=$[ $WIDTH / 2 * 2 ]					# Make it even 
	EMPTY="$(printf '%*s' $WIDTH)"					# Get 'width' spaces
	doEcho=false
	doHeader=false
	doTitle=false
	optStyle=""
#
#	Catching Arguments
#
	#[[ -z $1 ]] && printf "$help_text" && exit $RET_HELP
	while getopts "EHTh?" name
	do 	case $name in
		E|echo) 	doEcho=true
				optStyle="-E"	;;
		H|header)	doHeader=true
				optStyle="-H"	;;
		T|title)	doTitle=true
				optStyle="-T"	;;
		h|"?"|*)	printf "$help_text"
				exit $RET_HELP
				;;
		esac
	done
	shift $(($OPTIND - 1))
	ARGS=(${*})			# Remaining arguments	| These two fail on spaced-strings
	ARGS_COUNT_org=${#ARGS[@]}	# Amount of remaining
	#FIRST="${ARGS[0]}"
	#SECOND="${ARGS[1]}"
	#THIRD="${ARGS[2]}"
	ARGS_COUNT=0
	[ ! -z "$1" ] && FIRST="$1" && ((ARGS_COUNT++))
	[ ! -z "$2" ] && SECOND="$2" && ((ARGS_COUNT++))
	[ ! -z "$3" ] && THIRD="$3" && ((ARGS_COUNT++))
	[ ! -z "$4" ] && doMore=true || doMore=false
#
#	Verify all fit on 1 line
#
	len=$[ ${#FIRST} + ${#SECOND} + ${#THIRD} ]
	if [[ $len -gt $WIDTH ]]
	then 	len2=$[ ${#FIRST} + ${#SECOND} ]
		#echo $len $len2 $WIDTH
		if [[ $len2 -le $WIDTH ]]
		then 	# first & second match on one line
			tui-printf -E "$FIRST" "$SECOND"
			tui-printf $optStyle "$THIRD"
		else	# it needs further spliting:
			if [[ ${#FIRST} -le $WIDTH ]]
			then 	tui-printf -E "$FIRST"
				tui-printf $optStyle "$SECOND" "$THIRD"
			else	half=$[ ${#FIRST} / 2 ]
				part1="${FIRST:0:$half}"
				part2="${FIRST:$half}"
				tui-printf -E "$part1"
				[[ -z $SECOND ]] && \
					tui-printf -E "$part2" || \
					tui-printf -E "$part2" "$SECOND"
				[[ -z $THIRD ]] || \
					tui-printf $optStyle "$THIRD"
			fi
		fi
		# Since this is special handling, 
		# calling itself with reduced string lengths
		# so we can exit after this is done
		exit
	# else # just continue with the script below
	fi
#
#	Prepare Colors & Strings
#
	if [ $doEcho = true ]
	then	COLOR_LINE_START="\r${TUI_RESET}"
		COLOR_LINE_IDENT=""
		COLOR_LINE_CLOSE=""
		COLOR_LINE_END="\n"
	elif [ $doHeader = true ]
	then	# Full line
		COLOR_LINE_START="\r${HEAD_BG}${HEAD_FG}"
		COLOR_LINE_IDENT=""
		COLOR_LINE_CLOSE=""
		COLOR_LINE_END="${TUI_RESET}\n"
	elif [ $doTitle = true ]
	then	# 'Inlay'
		COLOR_LINE_START="\r"
		COLOR_LINE_IDENT="${TITLE_FG}${TITLE_BG}"
		COLOR_LINE_CLOSE="${TUI_RESET}"
		COLOR_LINE_END="\n"
	else	# The default
		COLOR_LINE_START="\r${TUI_RESET}"
		COLOR_LINE_IDENT=""
		COLOR_LINE_CLOSE=""
		COLOR_LINE_END=""
	fi
	case $ARGS_COUNT in
	0)	FIRST="$EMPTY"
		;;
	1)	if [ $doTitle = true ]
		then 	SECOND="$FIRST"
			num_o="${#SECOND}"
			num=$[ $num_o / 2 * 2  ]
			[ $num_o -gt $num ] && adder=" "||adder="  "
			EMPTY="${EMPTY:${num}+2}"	# The +2 is a temp bugfix
			half=$[ ${#EMPTY} / 2  ]
			FIRST="${EMPTY:$half}"
			THIRD="$FIRST$adder"
		else	# Usual arangement
			SECOND=$"${EMPTY:${#FIRST}}"
		fi
		;;
	2)	THIRD="$SECOND"
		SECOND="${EMPTY:${#FIRST}+${#SECOND}}"
		;;
	*)	# 3 (BETA - and more - handler)
		EMPTY="${EMPTY:${#FIRST}+${#SECOND}+${#THIRD}}"
		half=$[ ${#EMPTY} / 2 ]
		
		len_strings=$[ ${#FIRST} + ${#SECOND} + ${#THIRD} ]
		len_compare=$[ $len_strings / 2 * 2  ]
		[ $len_compare -lt $len_strings ] && \
			adder=1 || \
			adder=0
		
		SECOND="${EMPTY:$half}$SECOND${EMPTY:$half+$adder}"
		;;
	esac
#
#	Display & Action
#
	printf "${COLOR_LINE_START}${BORDER_LEFT}${COLOR_LINE_IDENT} ${FIRST}${SECOND}${THIRD} ${COLOR_LINE_CLOSE}${BORDER_RIGHT}${COLOR_LINE_END}"
#
#	BETA "if more"
#
	#unset ARGS[0] ARGS[1] ARGS[2]
	if [ $doMore = true ]
	then	# there are remains..
		C=0
		for A in "${ARGS[*]}";do 
			[ "$1" = "$A" ] && unset ARGS[$C] && echo $A
			[ "$2" = "$A" ] && unset ARGS[$C] && echo $A
			[ "$3" = "$A" ] && unset ARGS[$C] && echo $A
			((C++))
		done
		tui-title "DEBUG"
		tui-echo  "Too many arguments:" "$ARGS_COUNT($ARGS_COUNT_org)=${ARGS[*]}"
		# DEBUG
		echo $ME $optStyle "${ARGS[*]}"
		exit
	fi
